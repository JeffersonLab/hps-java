package org.hps.readout.ecal.updated;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.hps.conditions.database.DatabaseConditionsManager;
import org.hps.conditions.ecal.EcalChannelConstants;
import org.hps.conditions.ecal.EcalConditions;
import org.hps.readout.ReadoutDataManager;
import org.hps.readout.ReadoutDriver;
import org.hps.readout.util.collection.LCIOCollectionFactory;
import org.hps.recon.ecal.EcalRawConverter;
import org.lcsim.event.CalorimeterHit;
import org.lcsim.event.EventHeader;
import org.lcsim.event.RawCalorimeterHit;
import org.lcsim.event.SimCalorimeterHit;
import org.lcsim.geometry.Detector;
import org.lcsim.geometry.subdetector.HPSEcal3;
import org.lcsim.lcio.LCIOConstants;

/**
 * Class <code>EcalReadoutRawConverterDriver</code> serves as an
 * interface to the {@link org.hps.recon.ecal.EcalRawConverter
 * EcalRawConverter} object that is responsible for converting raw
 * hits generated by the driver {@link
 * org.hps.readout.ecal.updated.EcalReadoutDriver EcalReadoutDriver}
 * into proper {@link org.lcsim.event.CalorimeterHit CalorimeterHit}
 * objects to be used in clustering.
 * 
 * @author Kyle McCarty <mccarty@jlab.org>
 */
public class EcalReadoutRawConverterDriver extends ReadoutDriver {
    
    // ==============================================================
    // ==== LCIO Collections ========================================
    // ==============================================================
    
    /**
     * Sets the name of the input {@link
     * org.lcsim.event.RawCalorimeterHit RawCalorimeterHit}
     * collection.
     */
    private String inputCollectionName = "EcalRawHits";
    /**
     * Sets the name of the output {@link
     * org.lcsim.event.CalorimeterHit CalorimeterHit} collection.
     */
    private String outputCollectionName = "EcalCorrectedHits";
    /**
     * Defines the name of the collection that contains the truth
     * relations for raw hits.
     */
    // TODO: Truth propagation is disabled.
    //private String truthRelationsCollectionName = "TriggerPathTruthRelations";
    
    // ==============================================================
    // ==== Driver Options ==========================================
    // ==============================================================
    
    /**
     * Indicates whether channels that are marked as "bad" in the
     * conditions database should be skipped when producing hits.
     */
    private boolean skipBadChannels = true;
    /**
     * Specifies whether truth information is to be persisted through
     * this driver. If set to true, the driver will attempt to access
     * calorimeter truth relations and will merge them into the hits
     * it generates. An error will occur if these relations are not
     * found. 
     */
    private boolean persistTruth = false;
    
    // ==============================================================
    // ==== Driver Parameters =======================================
    // ==============================================================
    
    /**
     * The converter object responsible for processing raw hits into
     * proper {@link org.lcsim.event.CalorimeterHit CalorimeterHit}
     * objects.
     */
    private EcalRawConverter converter = new EcalRawConverter();
    /**
     * Cached copy of the calorimeter conditions. All calorimeter
     * conditions should be called from here, rather than by directly
     * accessing the database manager.
     */
    private EcalConditions ecalConditions = null;
    /**
     * Tracks the current local time in nanoseconds for this driver.
     */
    private double localTime = 0.0;
    
    @Override
    public void detectorChanged(Detector detector) {
        // Reset the converter calorimeter conditions.
        converter.setDetector(detector);
        
        // Cache the calorimeter conditions object.
        ecalConditions = DatabaseConditionsManager.getInstance().getEcalConditions();
        
        // Get the readout name from the calorimeter geometry data.
        HPSEcal3 calorimeterGeometry = (HPSEcal3) detector.getSubdetector("Ecal");
        ReadoutDataManager.updateCollectionReadoutName(outputCollectionName, CalorimeterHit.class, calorimeterGeometry.getReadout().getName());
    }
    
    @Override
    public void process(EventHeader event) {
        // Check the data management driver to determine whether the
        // input collection is available or not.
        if(!ReadoutDataManager.checkCollectionStatus(inputCollectionName, localTime + 4.0)) {
            return;
        }
        
        // Get all of the raw hits in the current clock-cycle.
        Collection<RawCalorimeterHit> rawHits = ReadoutDataManager.getData(localTime, localTime + 4.0, inputCollectionName, RawCalorimeterHit.class);
        
        // TODO: Truth propagation is disabled for the moment.
        /*
        // Prepare the truth information, if applicable.
        Collection<LCRelation> truthRelations = null;
        Map<RawCalorimeterHit, Set<SimCalorimeterHit>> hitToTruthMap = null;
        if(persistTruth) {
            truthRelations = ReadoutDataManager.getData(localTime, localTime + 4.0, truthRelationsCollectionName, LCRelation.class);
            hitToTruthMap = EcalRawConverterDriver.getTruthMap(truthRelations, RawCalorimeterHit.class);
        }
        */
        
        // Increment the local time.
        localTime += 4.0;
        
        // Pass the raw hits to the raw converter to obtain proper
        // calorimeter hits. In readout, raw hits are always Mode-3,
        // so there is no need to check the form.
        List<CalorimeterHit> newHits = new ArrayList<CalorimeterHit>();
        
        // TODO: Truth propagation is disabled.
        //List<SimCalorimeterHit> newTruthHits = new ArrayList<SimCalorimeterHit>();
        
        for(RawCalorimeterHit hit : rawHits) {
            // Convert the raw hit.
            CalorimeterHit newHit = converter.HitDtoA(event, hit, 0.0);
            
            // TODO: Truth propagation is disabled.
            /*
            // If truth information exists, extract it and store it
            // as a part of the hit by converting the hit to an
            // identical SimCalorimeterHit object, except now with
            // the extra truth data.
            SimCalorimeterHit truthHit = null;
            if(persistTruth) {
                Set<SimCalorimeterHit> truthHits = hitToTruthMap.get(hit);
                truthHit = CalorimeterHitUtilities.convertToTruthHit(newHit, truthHits, newHit.getMetaData());
            }
            */
            
            // If the hit is on a bad channel, and these are set to
            // be skipped, ignore the hit. Otherwise, add it to the
            // output list.
            if(skipBadChannels && isBadChannel(newHit)) {
                continue;
            }
            
            // If the truth data is not available, just output a
            // CalorimeterHit. If truth data is available, then
            // instead output a SimCalorimeterHit.
            // TODO: Truth propagation is disabled.
            /*
            if(truthHit == null) {
                newHits.add(newHit);
            } else {
                newTruthHits.add(truthHit);
            }
            */
            newHits.add(newHit);
        }
        
        // Add the calorimeter hit collection to the data manager.
        // TODO: Truth propagation is disabled.
        /*
        if(persistTruth) {
            ReadoutDataManager.addData(outputCollectionName, newTruthHits, SimCalorimeterHit.class);
        } else {
            ReadoutDataManager.addData(outputCollectionName, newHits, CalorimeterHit.class);
        }
        */
        ReadoutDataManager.addData(outputCollectionName, newHits, CalorimeterHit.class);
    }
    
    @Override
    public void startOfData() {
        // Set the LCIO flags for the output collection. Flags are
        // set to store the hit time and hit position respectively.
        int flags = 0;
        flags += 1 << LCIOConstants.RCHBIT_TIME;
        flags += 1 << LCIOConstants.RCHBIT_LONG;
        
        // Define the LCSim collection parameters for this driver's
        // output.
        LCIOCollectionFactory.setCollectionName(outputCollectionName);
        LCIOCollectionFactory.setProductionDriver(this);
        LCIOCollectionFactory.setFlags(flags);
        //LCIOCollection<CalorimeterHit> hitCollectionParams = LCIOCollectionFactory.produceLCIOCollection(CalorimeterHit.class);
        
        // Set the dependencies for the driver and register its
        // output collections with the data management driver.
        addDependency(inputCollectionName);
        if(persistTruth) {
            ReadoutDataManager.registerCollection(LCIOCollectionFactory.produceLCIOCollection(SimCalorimeterHit.class), isPersistent(),
                    getReadoutWindowBefore(), getReadoutWindowAfter());
        } else {
            ReadoutDataManager.registerCollection(LCIOCollectionFactory.produceLCIOCollection(CalorimeterHit.class), isPersistent(),
                    getReadoutWindowBefore(), getReadoutWindowAfter());
        }
    }
    
    @Override
    protected double getTimeDisplacement() {
        return 0;
    }

    @Override
    protected double getTimeNeededForLocalOutput() {
        return 0;
    }
    
    /**
     * Gets the channel parameters for a given channel ID.
     * @param cellID - The <code>long</code> ID value that represents
     * the channel. This is typically acquired from the method {@link
     * org.lcsim.event.CalorimeterHit#getCellID() getCellID()} in a
     * {@link org.lcsim.event.CalorimeterHit CalorimeterHit} object.
     * @return Returns the channel parameters for the channel as an
     * {@link org.hps.conditions.ecal.EcalChannelConstants
     * EcalChannelConstants} object.
     */
    private EcalChannelConstants findChannel(long cellID) {
        return ecalConditions.getChannelConstants(ecalConditions.getChannelCollection().findGeometric(cellID));
    }
    
    /**
     * Indicates whether or not the channel on which a hit occurs is
     * a "bad" channel according to the conditions database.
     * @param hit - The hit to check.
     * @return Returns <code>true</code> if the hit channel is
     * flagged as "bad" and <code>false</code> otherwise.
     */
    private boolean isBadChannel(CalorimeterHit hit) {
        return findChannel(hit.getCellID()).isBadChannel();
    }
    
    /**
     * Indicates whether or not data from channels flagged as "bad"
     * in the conditions system should be ignored. <code>true</code>
     * indicates that they should be ignored, and <code>false</code>
     * that they should not.
     * @param apply - <code>true</code> indicates that "bad" channels
     * will be ignored and <code>false</code> that they will not.
     */
    public void setSkipBadChannels(boolean state) {
        skipBadChannels = state;
    }
    
    /**
     * Sets the name of the input collection containing the objects
     * of type {@link org.lcsim.event.RawCalorimeterHit
     * RawCalorimeterHit} that are output by the digitization driver.
     * This is <code>"EcalRawHits"</code> by default.
     * @param collection - The name of the input raw hit collection.
     */
    public void setInputCollectionName(String collection) {
        inputCollectionName = collection;
    }
    
    /**
     * Sets the number of integration samples that should be included
     * in a pulse integral after the threshold-crossing event.
     * @param samples - The number of samples, where a sample is a
     * 4 ns clock-cycle.
     */
    public void setNsa(int samples) {
        converter.setNSA(4 * samples);
    }
    
    /**
     * Sets the number of integration samples that should be included
     * in a pulse integral before the threshold-crossing event.
     * @param samples - The number of samples, where a sample is a
     * 4 ns clock-cycle.
     */
    public void setNsb(int samples) {
        converter.setNSB(4 * samples);
    }
    
    /**
     * Sets the name of the output collection containing the objects
     * of type {@link org.lcsim.event.CalorimeterHit CalorimeterHit}
     * that are output by this driver. This is
     * <code>"EcalCorrectedHits"</code> by default.
     * @param collection - The name of the output hit collection.
     */
    public void setOutputCollectionName(String collection) {
        outputCollectionName = collection;
    }
    
    /**
     * Sets whether the driver should use calorimeter truth relations
     * and include this data in the hits generates. If enabled, all
     * truth hits associated with a given raw hit will have their
     * contribution references merged into the output hit. This will
     * cause an exception if the truth information is not available.
     * If disabled, no truth information is included or needed.
     * @param state - <code>true</code> enables the merging of truth
     * information, and <code>false</code>  disables it.
     */
    public void setPersistTruth(boolean state) {
        persistTruth = state;
    }
    
    /**
     * Sets the name of the collection that contains the hit truth
     * relations.
     * @param collection - The collection name.
     */
    // TODO: Truth propagation is disabled.
    /*
    public void setTruthRelationsCollectionName(String collection) {
        truthRelationsCollectionName = collection;
    }
    */
}